<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="css/normalize.css"><link rel="stylesheet" type="text/css" href="index.css"><link rel="stylesheet" type="text/css" href="css/highlightjs/ir-black.css"><title></title></head><body><div id="bfx-oss-docs-side-bar"><img id="bfx-oss-docs-side-bar__header" src="img/bfx-logo-bg-white.png" alt="Bitfinex" height="64"><ul id="bfx-oss-docs-side-bar__main-menu"><li><a href="/index.html">Home</a></li><li><a href="/page_v2_overview_introduction.html">API v2 Overview</a></li><li><a href="/page_v2_reference.html">API v2 Reference</a></li><li><a href="/page_v1_overview_introduction.html">API v1 Overview</a></li><li><a href="/page_v1_reference.html">API v1 Reference</a></li><li><a href="/page_oss_projects.html">Open Source Projects</a></li></ul><div class="bfx-oss-docs-side-bar__sub-menu" id="bfx-oss-docs-side-bar__api-reference-menu"><h6>Reading the Documentation (WS)</h6><ul><li><a href="/page_v2_overview_abbreviations_glossary.html">Abbreviation Glossary</a></li><li><a href="/page_v2_overview_changelog.html">Changelog</a></li><li><a href="/page_v2_overview_derivatives.html">API Derivatives Trading</a></li><li><a href="/page_v2_overview_flag_values.html">Flag Values</a></li><li><a href="/page_v2_overview_honey_framework.html">Honey Framework</a></li><li><a href="/page_v2_overview_introduction.html">Introduction</a></li><li><a href="/page_v2_overview_open_source_libraries.html">Open Source Libraries</a></li><li><a href="/page_v2_overview_requirements_and_limitations.html">Requirements and Limitations</a></li><li><a href="/page_v2_overview_rest_auth.html">Authenticated Endpoints</a></li><li><a href="/page_v2_overview_rest_general.html">General</a></li><li><a href="/page_v2_overview_rest_public.html">Public Endpoints</a></li><li><a href="/page_v2_overview_rest_reading_the_api_documentation.html">Reading the Documentation (REST)</a></li><li><a href="/page_v2_overview_showcase.html">Showcase</a></li><li><a href="/page_v2_overview_ui_goodies.html">UI Goodies</a></li><li><a href="/page_v2_overview_ws_auth.html">Authenticated Channels</a></li><li><a href="/page_v2_overview_ws_general.html">General</a></li><li><a href="/page_v2_overview_ws_public.html">Public Channels</a></li><li><a href="/page_v2_overview_ws_reading_the_documentation.html">Reading the Documentation (WS)</a></li></ul></div></div><div id="bfx-oss-docs-content"><div id="bfx-oss-docs-header-bar"><h2>Documentation</h2><h2>Reading the Documentation (WS)</h2></div><div class="bfx-oss-docs-content-wrapper"><div class="bfx-oss-docs-md-content bfx-oss-docs-code-wrapper"><p>Each page in our API documentation follows a particular structure so as to make it as easy to use as possible. This article explains the structure of our documentation pages as well as some of the key concepts found in the documentation. The article also shows how the code examples found in our documentation pages can be interpreted and used. We will use the JavaScript examples here.</p><h3>Public WS Channels</h3><p>Below is an example of a documentation page for a public WS channel (click the image for a zoomed view).</p><p><img src="https://files.readme.io/a460893-WS_public_trades_example.png" alt="undefined"></p><ol><li>A title and short description of the general purpose of the channel.</li><li>Example code to subscribe to the channel.</li><li>Here you can select if you would like to view the model payload / response for subscribing to the channel, the structure and an example of a snapshot provided through the channel, or the structure and an example of any updates sent through the channel.</li><li>A model payload showing the different requests fields. In the Snapshot and Update tabs this shows a model of the snapshot or update using the stream fields found at 7.</li><li>An example response to the channel subscription. In the Snapshot and Update tabs you will find an example response with actual data here (below the model using stream field names).</li><li>Request fields that can be altered to change which data the feed will provide. In this example, the SYMBOL can be changed in the payload to determine for which trading pair you would like to receive trades data.</li><li>Stream fields show the different fields that can be present in a response. any field that you can find in the response map at 4. will be listed here with the expected data type and an explanation of field’s content.</li></ol><h2>Account Info Channel Events</h2><p>Account info channel events provide snapshots and updates regarding your account. You can learn more about this on the <a href="ref:ws-auth-account-info">Account Info</a> page.</p><p>Documentation pages for account info channel events are structured as follows:</p><p><img src="https://files.readme.io/9855566-WS_Trades_Account_info_example.png" alt="undefined"></p><ol><li>A title and short description of the general purpose of the events.</li><li>A general explanation of the account info channel and of the expected events and their associated TYPE codes.</li><li>Tabs that allow you to view either the snapshot or updates. (Not all of the account data in the account info channel has a snapshot, for some data there are only updates).</li><li>A model of the snapshot/update using stream field names. These names correspond to the stream fields at 6.</li><li>An example of the snapshot/update using actual data.</li><li>Stream fields show the different fields that can be present in an snapshot/update. Any field that you can find in the event models at point 4. will be listed here with the expected data type and an explanation.</li></ol><h3>Websocket Authenticated Inputs</h3><p><img src="https://files.readme.io/6424b4d-WS_Inputs.jpg" alt="undefined"></p><ol><li>A title and short description of the general purpose of the events.</li><li>General explanation of WS inputs.</li><li>Shows all the requests fields that could be added to the payload. A model of the payload can be found at 5. Any request fields not included their can simply be appended. Mandatory request fields are always shown in the example payload.</li><li>Here you can switch between viewing the payload model/example and the expected response.</li><li>A model payload showing how to enter the different request fields. The corresponding request fields can be found at 3.</li><li>An example payload with actual values entered.</li></ol><p>###Example Payload for Websocket Inputs</p><p>Below you can see an example payload for placing an order. the example payload does not include all possible request fields, but any additional fields can be appended.</p><pre><code class="hljs language-javascript">[
  <span class="hljs-number">0</span>,
  <span class="hljs-string">"on"</span>,
  <span class="hljs-literal">null</span>,
  {
    <span class="hljs-string">"gid"</span>: <span class="hljs-number">12345</span>,
    <span class="hljs-string">"cid"</span>: <span class="hljs-built_in">Date</span>.now(),
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"LIMIT"</span>,
    <span class="hljs-string">"symbol"</span> <span class="hljs-string">"tBTCUSD"</span>,
    <span class="hljs-string">"amount"</span>: <span class="hljs-string">"0.02"</span>,
    <span class="hljs-string">"price"</span>: <span class="hljs-string">"6500"</span>
  }
]
</code></pre><p>To send the payload, you will need to add it to the authentication code found on the <a href="doc:ws-auth">Authenticated Channels</a> page along with some additional code found on the <a href="ref:ws-auth-input">Websocket Inputs</a> page. The end result for an order using the fields shown in the example payload above would look like this:</p><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto-js'</span>) <span class="hljs-comment">// Standard JavaScript cryptography library</span>
<span class="hljs-keyword">const</span> WebSocket = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ws'</span>) <span class="hljs-comment">// Websocket library for Node</span>

<span class="hljs-keyword">const</span> apiKey = <span class="hljs-string">'&lt;API_KEY_HERE&gt;'</span> <span class="hljs-comment">// Users API credentials are defined here</span>
<span class="hljs-keyword">const</span> apiSecret = <span class="hljs-string">'&lt;API_SECRET_HERE&gt;'</span>

<span class="hljs-keyword">const</span> authNonce = <span class="hljs-built_in">Date</span>.now() * <span class="hljs-number">1000</span> <span class="hljs-comment">// Generate an ever increasing, single use value. (a timestamp satisfies this criteria)</span>
<span class="hljs-keyword">const</span> authPayload = <span class="hljs-string">'AUTH'</span> + authNonce <span class="hljs-comment">// Compile the authentication payload, this is simply the string 'AUTH' prepended to the nonce value</span>
<span class="hljs-keyword">const</span> authSig = crypto.HmacSHA384(authPayload, apiSecret).toString(crypto.enc.Hex) <span class="hljs-comment">// The authentication payload is hashed using the private key, the resulting hash is output as a hexadecimal string</span>

<span class="hljs-keyword">const</span> payload = {
  apiKey, <span class="hljs-comment">//API key</span>
  authSig, <span class="hljs-comment">//Authentication Sig</span>
  authNonce, 
  authPayload,
  <span class="hljs-attr">event</span>: <span class="hljs-string">'auth'</span>, <span class="hljs-comment">// The connection event, will always equal 'auth'</span>
}

<span class="hljs-keyword">const</span> wss = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">'wss://api.bitfinex.com/ws/2'</span>) <span class="hljs-comment">// Create new Websocket</span>

wss.on(<span class="hljs-string">'open'</span>, () =&gt; wss.send(<span class="hljs-built_in">JSON</span>.stringify(payload)))

<span class="hljs-keyword">const</span> inputDetails = {
  <span class="hljs-string">"gid"</span>: <span class="hljs-number">12345</span>,
  <span class="hljs-string">"cid"</span>: <span class="hljs-built_in">Date</span>.now(),
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"LIMIT"</span>,
  <span class="hljs-string">"symbol"</span>: <span class="hljs-string">'tBTCUSD'</span>,
  <span class="hljs-string">"amount"</span>: <span class="hljs-string">"0.02"</span>,
  <span class="hljs-string">"price"</span>: <span class="hljs-string">'6500'</span>
}

<span class="hljs-keyword">const</span> inputPayload = [<span class="hljs-number">0</span>, <span class="hljs-string">'on'</span>, <span class="hljs-literal">null</span>, inputDetails] <span class="hljs-comment">// Note how the payload is constructed here. It consists of an array starting with the CHANNEL_ID, TYPE, and PLACEHOLDER and is followed by the inputDetails object.</span>

<span class="hljs-comment">//Websocket Listener</span>

wss.on(<span class="hljs-string">'message'</span>, (msg) =&gt; {     <span class="hljs-comment">// The 'message' event is called whenever the ws recieves ANY message</span>
<span class="hljs-keyword">let</span> response = <span class="hljs-built_in">JSON</span>.parse(msg)
<span class="hljs-keyword">if</span> (response.event === <span class="hljs-string">'auth'</span>) {
  wss.send(<span class="hljs-built_in">JSON</span>.stringify(inputPayload));<span class="hljs-comment">// Submit payload for input</span>
}
<span class="hljs-built_in">console</span>.log(msg); <span class="hljs-comment">// ALL ws receipts will be logged to console</span>
})
</code></pre><p>Note how in this code you only need to change the inputDetails according to the type of input you wish to perform along with changing the TYPE abbreviation in the inputPayload. Which TYPE to use can be found on the documentation page for each different input event. You can also find a full list of the abbreviations used in our WS API in our <a href="doc:abbreviations-glossary">Abbreviation Glossary</a> .</p><p>Do note that this is just example code. If you wish to send multiple orders, there is no need to run the authentication code each time. Once an authenticated connection is opened you only need to send the payloads through the open channel.</p></div></div><div id="bfx-oss-docs-footer-bar"><div id="bfx-oss-docs-footer-bar__container"><p>Copyright © 2013-2020 iFinex Inc. All rights reserved.</p></div></div></div><script type="text/javascript" src="js/vendor/zepto.min.js"></script><script type="text/javascript" src="js/vendor/lodash.min.js"></script><script type="text/javascript" src="js/vendor/debug.min.js"></script><script type="text/javascript" src="js/debug_init.js"></script></body></html>